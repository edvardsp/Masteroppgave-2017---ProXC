% !TEX encoding = UTF-8 Unicode
%!TEX root = main.tex
% !TEX spellcheck = en-US
%%=========================================


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Examples of Usage}
\label{ch:examples_usage}

This chapter introduces how ProXC++ is used in C++ programs. Only the basics of ProXC++ is presented in this chapter, introducing all necessary features for understanding the library. For more advanced examples, check out the examples in the \texttt{examples/} folder on GitHub \citep{pettersen2017proxcgithub}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Prerequisites}
\label{sec:example_prerequisites}

First of all, ProXC++ must be installed on the work environment. ProXC++ is available free of charge on GitHub \citep{pettersen2017proxcgithub}, and following the install guide on the readme should be sufficient.

It is given the header file \lstinline[style={CustomC++}]|#include <proxc.hpp>| is included in all code examples shown in this chapter, as well as in all C++ files programming with ProXC++.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Library Features}
\label{sec:example_library_features}

The core feature of ProXC++ is lightweight processes called \texttt{Process}. These processes can communicate with each other via message\hyp{}passing, using \texttt{Channel}s. These channels allow for synchronous and safe communication. Simultaneous channel communication can be achieved through \texttt{Alting}. On top of this, several types of \texttt{Timer}s allows for soft real\hyp{}time requirements on different operations, such as channel operations and explicit process suspension.

Programs using ProXC++ does not need to initialize or cleanup the library. This is done automatically by the library. The first API call to the library will initialize the library, and when main exits will the library cleanup. No cleanup will be performed unless the library has been initialized. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Processes}

At the core of ProXC++ are lightweight processes. These processes is a separate scope of execution which can run concurrently with the rest of the program. In code, these processes are represented by a function and its corresponding arguments. This function must have a return type of \lstinline[style={CustomC++}]|void|, but can have any type and number of arguments. \cref{lst:code_example_process_func} shows a function which qualifies running as a process.

\begin{lstfloat}
\begin{lstlisting}[caption={Example of process function.}, label={lst:code_example_process_func}, style={CustomC++}]
void my_func(int x, std::string msg) {
    some_other_func(x);
    ... 
    std::cout << msg;
}
\end{lstlisting}
\end{lstfloat}

Processes can be created and stored freely in any container, but can only be spawned with the \texttt{parallel} statement. The parallel statement takes one\hyp{}or\hyp{}more processes and runs them concurrently with the rest of the program, following the fork\hyp{}join model. The process calling the parallel statement is suspended until all processes has terminated.

\begin{lstfloat}
\begin{lstlisting}[caption={The parallel statement.}, label={lst:parallel_statement}, style={CustomC++}]
std::vector< proxc::Process > funcs;
...
proxc::parallel(
    proxc::proc(&my_func, 42, "Normal function\n"),
    proxc::proc([](int y, std::string msg){
        for (int i = 0; i < y; ++i) {
            my_func(i, msg);
        }
    }, 1234, "Lambda function"),
    proxc::proc_for(funcs.begin(), funcs.end()),@\label{line:parallel_container_replicator}@
    proxc::proc_for(0, 10, &compute_something)@\label{line:parallel_range_replicator}@
);
\end{lstlisting}
\end{lstfloat}

\Cref{lst:parallel_statement} shows the different process definitions which can be called with the parallel statement. \texttt{proc} defines a single process, given function pointer and its corresponding arguments. \texttt{proc\_for} is a process replicator, generating a dynamic number of processes. A process replicator can either take a pre\hyp{}defined container of processes, shown in \cref{line:parallel_container_replicator}, or generate a number of processes given a range, shown in \cref{line:parallel_range_replicator}.

Process creation also has perfect forwarding of arguments, meaning any type of arguments being expensive to copy or being non\hyp{}copyable can correctly be moved into processes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Timers}

Three types of timers are available in ProXC++: egg, repeat and date timers. Timers allow for soft real\hyp{}time requirements on certain operations. All timers have support for time period and duration declarations using the standard time library \lstinline[style={CustomC++}]|std::chrono|.

Egg timers are used for relative timeout periods. Just as an egg timer in real life, the timer is starts when the operation starts, and expires when the time period has passed. The egg timer can be reused after expiration, as the countdown is reset every time it is supplied for an operation. In a sense, the timer does not ``survive'' between multiple operations, as it resets.

Repeat timers are used for periodic timeout periods. Given a time duration, the repeat timer will expire every period equal to the time duration. When supplied with an operation, the repeat timer does not reset. Only when it expires does it reset, basically setting the next timeout point to a period forward in time. Repeat timers do ``survive'' between multiple operations, as only when the expiration is registered does it reset. 

Date timers are used for absolute timeout periods. Given a time point, the date timer will expire when current time point has surpassed the given time point. The date timer does ``survive'' between multiple operations, however will always stay expired after timeout. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Channels}

Processes uses message\hyp{}passing to communicate, which is realized through channels. Channels in ProXC++ are synchronous, unbuffered, unidirectional, and type safe. 

The philosophy is processes should not share memory directly, as this is a potent problem often leading to race conditions. Rather, the processes should share memory by communicating, i.e. message\hyp{}passing with channels.

All channel related functions and types reside in the \lstinline[style={CustomC++}]|proxc::channel| namespace. Channels consists of two complementary ends, the sending and receiving ends, which are called \lstinline[style={CustomC++}]|Tx| and \lstinline[style={CustomC++}]|Rx|. As the name implies, the two channel ends can only send or receive data, respectively. A channel end can only have single owner, meaning they are non\hyp{}copyable. Passing a channel end to an another process must pass the ownership of that channel end. When creating a channel, the two channel end objects \lstinline[style={CustomC++}]|Tx| and \lstinline[style={CustomC++}]|Rx| are returned in a \lstinline[style={CustomC++}]|std::tuple|.

Channels are templated, making them type safe. Channel transmission also has perfect forwarding, meaning any type being expensive to copy or being non\hyp{}copyable can correctly be moved between processes.

A single channel can be created with the \lstinline[style={CustomC++}]|create<T>()| function, while $n$ channels can be created with the \lstinline[style={CustomC++}]|create_n<T>(n)| function. Channel ends can be extracted from the tuple with the convenience functions \lstinline[style={CustomC++}]|get_tx| and \lstinline[style={CustomC++}]|get_rx| for a single channel, and functions \lstinline[style={CustomC++}]|get_tx_ind| and \lstinline[style={CustomC++}]|get_rx_ind| for numerous channels. \Cref{lst:channel_creation} demonstrates channel creation and channel end extraction.

\begin{lstfloat}
\begin{lstlisting}[caption={Channel creation and channel end extraction.}, label={lst:channel_creation}, style={CustomC++}]
// using convenience functions
auto ch = proxc::channel::create<int>();
auto tx = proxc::channel::get_tx(ch);
auto rx = proxc::channel::get_rx(ch);
// using std::tie
proxc::channel::Tx<int> tx;
proxc::channel::Rx<int> rx;
std::tie(tx, rx) = proxc::channel::create<int>();
// with C++17 structured bindings
auto [ tx, rx ] = proxc::channel::create<int>();
\end{lstlisting}
\end{lstfloat}

Note that after extracting a channel end removes it entirely from the tuple. Trying to extract the same channel end twice from the same tuple is therefore undefined behaviour. 

Channel ends can either transmit data through methods or operator overloading. See \cref{lst:channel_operation_operator_overloading} for reference.

\begin{lstfloat}
\begin{lstlisting}[caption={Channel operation and operator overloading.}, label={lst:channel_operation_operator_overloading}, style={CustomC++}]
// these two expressions are equivalent
tx.send(data);
tx << data;
// these two expressions are equivalent
rx.recv(data);
rx >> data;
\end{lstlisting}
\end{lstfloat}

Channel ends can also be piped, which is the same as sending the output of a receiving channel end as the input of a sending channel end. The piped operation returns a boolean value indicating if the operation succeeded or not. See \cref{lst:channel_end_piping} for an example of channel end piping.

\begin{lstfloat}
\begin{lstlisting}[caption={Channel end piping.}, label={lst:channel_end_piping}, style={CustomC++}]
void some_process(proxc::channel::Tx<long> tx,
                  proxc::channel::Rx<long> rx) {
    while (tx << rx) {}
}
\end{lstlisting}
\end{lstfloat}

Channel operations can also be timed by any of the ProXC++ timers, or direct use of the time library \lstinline[style={CustomC++}]|std::chrono|. 

Processes can signal each other certain termination signals through closing channels. A channel remains closed after being closed. A channel can either be closed explicitly by a process closing a channel end, or a channel end going out of scope. A process can directly test whether a channel end is closed, or by inspecting the return result of a channel operation.

To simplify this closing concept, range\hyp{}based for loop semantics is implemented for receiving channel ends. The for loop will continue to read from the channel end, and exit when the channel end closes. See \cref{lst:channel_for_loop} for an example.

\begin{lstfloat}
\begin{lstlisting}[caption={Range\hyp{}based for loop semantics for receiving channel ends.}, label={lst:channel_for_loop}, style={CustomC++}]
void some_process(proxc::channel::Rx<int> rx) {
    for (auto data : rx) {
        compute(data);
    }
}
\end{lstlisting}
\end{lstfloat}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Alting}

If a process were to wait on multiple channel ends simultaneously, normal channel operations would not suffice. The alting construct however allows a process to do simultaneously wait on different alternatives. These alternatives include channel send and receive, as well as timeouts and skip.

The alting procedure allows a process to synchronously wait for multiple alternatives, and choose one when one\hyp{}or\hyp{}more are ready. A corresponding closure, which can be anything callable, is then executed if present. When the alting procedure finishes, including the executed closure has returned, the processes that is alting resumes execution.

Alting contains zero\hyp{}or\hyp{}more alternatives, where the alting procedure waits for these alternatives to become ``ready''. When one\hyp{}or\hyp{}more alternatives are ready, the alting procedure chooses one alternative and executes a corresponding closure. Alternatives can be guarded by a boolean condition, which enables or disables an alternative for the alting procedure depending on the condition.

An alting procedure starts with creating an alting object. This alting object can create alternatives by function chaining multiple alternative methods, and lastly call a selection method which consumes the alting object and resolves the alting procedure.

\begin{lstfloat}
\begin{lstlisting}[caption={Example of the alting construct.}, label={lst:alting_procedure}, style={CustomC++}]
Alt()
    .send(tx, 42)
    .recv_if(cond1, rx)
    .timeout(timer, &timeout_func)
    .skip_if(cond2, &skip_func)
    .select();
\end{lstlisting}
\end{lstfloat}

The four alternative types channel send, channel receive, timeout and skip has the corresponding alternative methods \lstinline[style={CustomC++}]|send|, \lstinline[style={CustomC++}]|recv|, \lstinline[style={CustomC++}]|timeout| and \lstinline[style={CustomC++}]|skip|, respectively. Each alternative method can prepend a guard with a boolean condition by calling the altered alternative method, which has an appended \lstinline[style={CustomC++}]|_if| to the method name, e.g. \lstinline[style={CustomC++}]|send_if|. All alternative methods, both with and without a guard, can have an optional closure. See \cref{lst:alting_procedure} for reference.

The four alternatives are as follows: channel send and receive takes an appropriate channel end and data, and performs the given channel operation. A timeout specifies a timer and wait until that timer has expired. A skip is always ready, much like the default keyword in a switch construct. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scheduling Policy}
\label{sec:scheduling_policy}

By default, ProXC++ is hard coded to use worker threads equal to the number of logical cores on the processor and work stealing for load balancing between the worker threads. There are currently no implemented API to directly change the scheduling policy. A round robin scheduling policy is implemented, but direct change in the implementation has to be made to enable the round robin policy.

