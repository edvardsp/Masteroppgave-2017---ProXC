% !TEX encoding = UTF-8 Unicode
%!TEX root = main.tex
% !TEX spellcheck = en-US
%%=========================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{ch:introduction}

Computers are for many the greatest engineering feat in the 20th century, taking into consideration the vast complexity, precision and knowledge it has required to reach the state of computers we have today. Since its inception with the transistor in the 40s, the computer has been subjected to numerous changes in different technology to further increase the performance. Such technology includes the decrease in size of transistors down to nanometers, faster clock rates for processors, and most notably the transition from singlecore to multicore processors.

When entering the 21th century, the main drive behind increasing processor performance was increasing the transistor count in the processor, following the exponential increase described by Moore's law for years. However, since 2005 this strategy was no longer sustainable. The physical limitations of the Dennard scaling was starting to show, and a shift from singlecore towards multicore processors was a response to this limitation. This is of course an oversimplification of the issue, but multicore processors are pretty much the norm among desktop computers in this day and age.

With the transition to multicore processors, software can no longer rely on increase in processor performance for an increase in software performance. Software has to now utilize the parallel power in multicore processors, which requires concurrent programming. Concurrent programming has existed long before multicore processors, but is now the main tool for developers to write scalable software which can utilize the parallel power in multicore processors.

Concurrent programming revolves around having multiple threads of execution running concurrently (simultaneously) in a program. Such programs are called concurrent systems. Even though concurrent programming is a powerful and expressive paradigm to write software in, it also is hard to reason whether a concurrent system behaves as specified by the programmer. What makes it hard to write correct and well\hyp{}behaved concurrent systems has to do with concurrency adding significant complexity to the system, as well as being an added mental overhead for the programmer. Even the simplest and most subtle errors in a program can explode into the most obscure and hard\hyp{}to\hyp{}track bugs. Being able to write expressive concurrent systems, as well as being able to reason about the correctness of the system, is probably the biggest challenge with concurrency.

\textit{Communicating Sequential Processes} (CSP) was an effort by \citet{hoare1978communicating} to harness the expressiveness of concurrent programming while being able to prove the correctness of such models. CSP is by its own a formal language used to describe concurrent models. These models described by CSP is a concurrent composition of sequential processes, which only communicate through mutually agreed message\hyp{}passing constructs. This inherently inhibits any types of race\hyp{}conditions with shared memory to ever occur. However, the real power of CSP comes from the ability to reason about the correctness of these models, such as absence of deadlocks and livelocks.  

Several programming languages has incorporated CSP formalism into the language, such as occam-$\pi$ \citep{barrett1992occam}, XC \citep{douglas2009programming} and Go \citep{go2009go}, but the mainstream popularity has not been great; Go is an exception, which ranks as one of the most popular languages to date. As a response, a collection of transpilers\footnote{Source\hyp{}to\hyp{}source compiler, compiling source code written in one language to source code in another language} and libraries to more popular, well\hyp{}established programming languages such as C \citep{pettersen2016proxc}, C++ \citep{brown2003c++csp,brown2007c++csp2,chalmers2016cppcsp}, Python \citep{bjorndalen2007pycsp}, Java \citep{welch2007jcsp}, and more. 

Concurrent systems written in CSP has a great potential for multicore processors, as CSP is inherently parallel and provides a model which can be reasoned about the correctness of the behaviour. However, not many CSP\hyp{}based frameworks does take advantage of processor power available in multicore processors. Existing libraries are either outdated for modern use, or does not satisfy performance wise. \Cref{ch:multicore_csp} takes this discussion further and argues there is a need for a modern solution.

With the lack of a modern CSP library for C, ProXC was developed, as a result of the work done by \citet{pettersen2016proxc}, to show the possibilities such a library could have. The focus of ProXC was however on the provided abstractions rather on performance, and support for multicore processors was not implemented. In this thesis, the work done on ProXC is continued with the aim to provide a portable CSP library for multicore processors. 

This thesis presents the work and results of ProXC++, a portable CSP library for modern C++ with support for multicore processors. ProXC++ is a concurrency library which uses dynamic multithreading combined with lightweight processes to achieve proper utilization of multicore processors. The runtime system employed by ProXC++ consists of a number of schedulers equal to the number of available processor cores. Each scheduler is responsible for scheduling and running these lightweight processes on a kernel\hyp{}thread, and uses work stealing to load balance work between schedulers. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project Status of ProXC}

As this thesis is a continuation of the work on ProXC done in the project thesis by \citet{pettersen2016proxc}, a short status report of ProXC the project is presented.

As of writing this thesis, ProXC has not undergone any major development, except for some bug fixes. The API has remained unchanged, as well as any of the major issues pinpointed by the project thesis. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thesis Structure}


The thesis is structured into three parts. \Cref{part:preliminaries} discusses the theoretical basis of this thesis, as well as arguing the motivation behind multicore CSP: \Cref{ch:theoretical_background} gives an introduction to concurrent programming, and details all relevant theoretical knowledge for which this thesis is based on. \Cref{ch:multicore_csp} argues there is a motivation for a multicore CSP library, and provides a summary of existing solutions and how they work. 

\Cref{part:proxc++} details the work regarding ProXC++: \Cref{ch:proxc_library} details the library specification. \Cref{ch:design_implementation} presents the design and implementation. \Cref{ch:examples_usage} presents examples of how ProXC++ is used along with code examples. \Cref{ch:performance} performs a benchmark of ProXC++ compared to existing solutions, both highlighting the difference between singlecore and multicore implementations.

\Cref{part:discussions} discusses different aspects of multicore CSP, limitation and uses of ProXC++, and concludes the thesis: \Cref{ch:proxc++_vs_proxc} compares both projects, drawing the differences and similarities between the multicore and singlecore library. \Cref{ch:difficulty_multicore_csp} explains the challenges with implementing a multicore CSP framework. \Cref{ch:shortcomings_limitations} discusses the limitations and uses of ProXC++. \Cref{ch:future_work} lists a set of potential future work. \Cref{ch:conclusion} draws a conclusion for the thesis.


Lastly, the appendices list the FIXME
