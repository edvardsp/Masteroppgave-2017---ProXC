% !TEX encoding = UTF-8 Unicode
%!TEX root = main.tex
% !TEX spellcheck = en-US
%%=========================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{ch:introduction}


In this day and age, multicore processors seems to have been the next big step in processor evol\-ution. Ever since singlecore processors hit the physical limitations of Moore's law, it was no longer sustainable to \textit{just} increase the number of transistors and clock frequency in a processor. This is of course an oversimplification of the issue, but the transition to multicore processors is very much real, as well as the amount of research currently going into multicore processors.


Back in the days when developing software, an often viable strategy when performance was not adequate was to wait for faster and more performant hardware. This mainly relied on sequential software scaling in performance with the increase in performance of singlecore processors. With multicore processors, this strategy is no longer feasible. Software needs to be developed with more efficient utilization of processor resources, and scalability of said resources. 


Concurrent programming is the main tool for programmers to develop such software. Even though concurrent programming has existed long before multicore became the predominant architecture, it forms the foundation allowing software to take advantage of this parallel processing capability. Concurrent programming is a great way to model and implement systems which are inherently parallel, as it introduces powerful concepts for expressing such parallel compositions in software. However it also introduces new potential challenges which could cause unwanted behaviour.


Communicating Sequential Processes (CSP) was an effort by Tony Hoare to harness the expressiveness of concurrent programming while being able to prove the correctness of such models. CSP is not programming language, but a formal language used to describe concurrent systems. These systems are described by a concurrent composition of sequential processes, which only communicate through message-passing.


Several programming languages (occam-$\pi$, Go, XC) exists which incorporate the CSP formalism to various degrees, but the mainstream popularity has not been great; Go is an exception, which ranks as one of the most popular languages to date. As a response to this lack of mainstream popularity, a collection of libraries and transpilers have been created to offer the CSP formalism to better established languages and platforms. This includes languages such as C++, Python, Java, and more. 


As a lack of a modern CSP library for C and C++, the library ProXC was created as an attempt to fill this void. ProXC was based on user-threads, with no support for multicore. This allowed for fairly simple design of the runtime system, including the scheduler, channel, and alternation. ProXC gave promising results compared to what Go and occam achieved on a singlecore, but was not able to provide a multicore design nor implementation. A multicore design and implementation of such library could potentially be beneficial for utilizing the vast resources of multicore processors which currently exists. 


This report introduces ProXC++, a concurrency library for C++. ProXC++ offers many of the same features ProXC provides, however ProXC++ provides multicore support acheived through dynamic multithreading. ProXC++ is written in C++14. The design and implementation of ProXC++ is presented in this report, examples on how ProXC++ can be used, and how it performs compared to existing languages and libraries. Further on, limitations and uses is discussed, as well as future work. A conclussion is drawn.  blah blah blah.

